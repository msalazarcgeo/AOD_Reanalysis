# AUTOGENERATED! DO NOT EDIT! File to edit: ../get_PBLH_program.ipynb.

# %% auto 0
__all__ = ['get_mean_day', 'resample_raster', 'getFeatures', 'cut_bbox_zona_met', 'add_band', 'res_bound_merge']

# %% ../get_PBLH_program.ipynb 1
from mpl_toolkits.basemap import Basemap  # import Basemap matplotlib toolkit
import numpy as np
import matplotlib.pyplot as plt
import re
import pygrib # import pygrib interface to grib_api
import os
from datetime import datetime, timedelta
import pytz
import pyproj
import shapely
import rasterio
import geopandas as gpd
from rasterio.warp import calculate_default_transform, reproject, Resampling
from rasterio.mask import mask




# %% ../get_PBLH_program.ipynb 4
def get_mean_day(
        date_start_str,
        date_final_str, 
        file_path, 
        save_prefix= 'PBLH_', 
        save_path = './data/raster/ECMWF_rasters/'
        
        ):
    """Gets the day mean and save it on a given location """

    date_valid_start = datetime.strptime(date_start_str, '%Y-%m-%d').replace(tzinfo = pytz.timezone('America/Mexico_City'))
    date_valid_start = date_valid_start.astimezone(pytz.utc)

    print('starting date:',date_valid_start )
    date_valid_final = datetime.strptime(date_final_str, '%Y-%m-%d').replace(tzinfo = pytz.timezone('America/Mexico_City'))
    date_valid_final = date_valid_final.astimezone(pytz.utc)
    print('final date:',date_valid_final )
    while (date_valid_start<=date_valid_final):

        next_day = date_valid_start + timedelta(days=1)
        #print(next_day)
        grbs_2 = pygrib.open(file_path)

        day_list =[grb.data() for grb in grbs_2  if pytz.UTC.localize(grb.validDate) >= date_valid_start and pytz.UTC.localize(grb.validDate) < next_day ]
        
        day_list_data = [data[0] for data in day_list] 
        
        day_mean=  np.mean(day_list_data,  axis=0, keepdims=True)

        str_day =date_valid_start.date().strftime("%Y_%m_%d")
        file_save_name= save_path+save_prefix+str_day+'.tif'
        ### se abre la localización en disco y se salva el raster promedio
        ### Pero es necesario obtener la transformacion del raster
        #print(day_mean[0].shape)
        bbox_size_r = (day_mean[0].shape[0], day_mean[0].shape[1])

        min_lat_r = day_list[0][1].min()
        max_lat_r = day_list[0][1].max()
        min_lon_r = day_list[0][2].min()
        max_lon_r = day_list[0][2].max()


        lat_size_r  = day_list[0][1][0][0]- day_list[0][1][1][0] 
        long_size_r = day_list[0][2][0][0]- day_list[0][2][0][1] 

        min_lat_r= min_lat_r - (lat_size_r/2)
        max_lat_r= max_lat_r + (lat_size_r/2)
        min_lon_r= min_lon_r + (long_size_r/2)
        max_lon_r= max_lon_r - (long_size_r/2)
        bbox_r = [min_lon_r, min_lat_r, max_lon_r, max_lat_r]
        transform_r= rasterio.transform.from_bounds(
            *bbox_r, width=bbox_size_r[1], height=bbox_size_r[0]
        )
        print('Saving file :',file_save_name )
        #print(day_mean[0].shape)
        with rasterio.open(
            file_save_name,
            mode="w",
            driver="GTiff",
            height= day_mean[0].shape[0],
            width=  day_mean[0].shape[1],
            count=1,
            dtype= day_mean[0].dtype,
            crs="+proj=latlong",
            transform=transform_r
        ) as new_dataset:
            new_dataset.write(day_mean[0], 1)
            new_dataset.set_band_description(1, "PBLH")
            new_dataset.update_tags(1, DATETIME=str_day)

            new_dataset.close()
        grbs_2.close()
        date_valid_start= next_day

    return 

def get_mean_day_band(
        date_start_str,
        date_final_str, 
        file_path, 
        band= 'Boundary layer height',
        save_prefix= 'PBLH_', 
        save_path = './data/raster/ECMWF_rasters/'
        
        ):
    """Gets the day mean and save it on a given location """

    dic_names={
            'Boundary layer height':'PBLH', 
            '2 metre temperature':'temperature_2m',
            '2 metre dewpoint temperature':'dewpoint_temperature_2m',
            'Total precipitation':'total_precipitation'
            }

    date_valid_start = datetime.strptime(date_start_str, '%Y-%m-%d').replace(tzinfo = pytz.timezone('America/Mexico_City'))
    date_valid_start = date_valid_start.astimezone(pytz.utc)

    print('starting date:',date_valid_start )
    date_valid_final = datetime.strptime(date_final_str, '%Y-%m-%d').replace(tzinfo = pytz.timezone('America/Mexico_City'))
    date_valid_final = date_valid_final.astimezone(pytz.utc)
    print('final date:',date_valid_final )
    while (date_valid_start<=date_valid_final):
        print('band:', band)
        next_day = date_valid_start + timedelta(days=1)
        #print(next_day)
        grbs_2 = pygrib.open(file_path)
        band_selected = grbs_2.select(name=band)
        day_list =[grb.data() for grb in band_selected  if pytz.UTC.localize(grb.validDate) >= date_valid_start and pytz.UTC.localize(grb.validDate) < next_day ]
        
        day_list_data = [data[0] for data in day_list] 
        
        day_mean=  np.mean(day_list_data,  axis=0, keepdims=True)

        str_day =date_valid_start.date().strftime("%Y_%m_%d")
        file_save_name= save_path+save_prefix+str_day+'.tif'
        ### se abre la localización en disco y se salva el raster promedio
        ### Pero es necesario obtener la transformacion del raster
        #print(day_mean[0].shape)
        bbox_size_r = (day_mean[0].shape[0], day_mean[0].shape[1])

        min_lat_r = day_list[0][1].min()
        max_lat_r = day_list[0][1].max()
        min_lon_r = day_list[0][2].min()
        max_lon_r = day_list[0][2].max()


        lat_size_r  = day_list[0][1][0][0]- day_list[0][1][1][0] 
        long_size_r = day_list[0][2][0][0]- day_list[0][2][0][1] 

        min_lat_r= min_lat_r - (lat_size_r/2)
        max_lat_r= max_lat_r + (lat_size_r/2)
        min_lon_r= min_lon_r + (long_size_r/2)
        max_lon_r= max_lon_r - (long_size_r/2)
        bbox_r = [min_lon_r, min_lat_r, max_lon_r, max_lat_r]
        transform_r= rasterio.transform.from_bounds(
            *bbox_r, width=bbox_size_r[1], height=bbox_size_r[0]
        )
        print('Saving file :',file_save_name )
        #print(day_mean[0].shape)

        band_name= dic_names[band]
        with rasterio.open(
            file_save_name,
            mode="w",
            driver="GTiff",
            height= day_mean[0].shape[0],
            width=  day_mean[0].shape[1],
            count=1,
            dtype= day_mean[0].dtype,
            crs="+proj=latlong",
            transform=transform_r
        ) as new_dataset:
            new_dataset.write(day_mean[0], 1)
            new_dataset.set_band_description(1, band_name)
            new_dataset.update_tags(1, DATETIME=str_day)

            new_dataset.close()
        grbs_2.close()
        date_valid_start= next_day

    return 






# %% ../get_PBLH_program.ipynb 7
def resample_raster(file_raster, 
                    file_reference, 
                    file_save_resample, 
                    dic_coord,
                    set_date_file = True 
                    ):
    """
    Function to resample and save the new raster
    """
    
    min_lat_r = dic_coord['min_lat_r']
    max_lat_r = dic_coord['max_lat_r']
    min_lon_r = dic_coord['min_lon_r']
    max_lon_r = dic_coord['max_lon_r']
    lat_size_r = dic_coord['lat_size_r'] 
    lon_size_r = dic_coord['lon_size_r'] 

    reference_rasters =  rasterio.open(file_reference, 'r', driver =  'GTiff')
    

    min_lat_r= min_lat_r - (lat_size_r/2)
    max_lat_r= max_lat_r + (lat_size_r/2)
    min_lon_r= min_lon_r + (lon_size_r/2)
    max_lon_r= max_lon_r - (lon_size_r/2)

    up_left =   (min_lon_r, max_lat_r) 
    up_right =  (max_lon_r, max_lat_r)
    bot_left =  (max_lon_r, min_lat_r)
    bot_right  = (min_lon_r, min_lat_r)
    print(up_left, up_right, bot_right, bot_left)
    esquinas = gpd.GeoDataFrame([up_left, up_right, bot_right, bot_left])
    esquinas["Lon"] = esquinas[0]
    esquinas["Lat"] = esquinas[1] 

    esquinas["geometry"] = esquinas.apply(lambda l: shapely.geometry.Point((l.Lon,l.Lat)), axis=1)
    esquinas= esquinas.set_crs('EPSG:4326')
    esquinas_mod = esquinas.to_crs(reference_rasters.meta['crs'])
    print(esquinas_mod)
    ### Se obtiene la nueva transformacion 
    d_x = esquinas_mod['geometry'][3].x - esquinas_mod['geometry'][2].x
    d_y = esquinas_mod['geometry'][1].y - esquinas_mod['geometry'][3].y
    print("show x")
    print(reference_rasters.res[0])
    print(d_x)
    print("show y")
    print(reference_rasters.res[1])
    print(d_y)

    n_pixel_x = d_x/reference_rasters.res[0]
    print("number of pixels in x:", n_pixel_x)
    n_pixel_y = d_y/reference_rasters.res[1]
    print("number of pixels in x:", n_pixel_y)

    res_x= -(esquinas_mod['Lon'][0]- esquinas_mod['Lon'][1])/int(n_pixel_x)
    res_y= -(esquinas_mod['Lat'][0] - esquinas_mod['Lat'][2])/int(n_pixel_y)

    translate_affine = rasterio.transform.Affine.translation(
        esquinas_mod['Lon'][0] - res_x / 2,
        esquinas_mod['Lat'][0] - res_y / 2
    )


    scale_affine = rasterio.transform.Affine.scale(res_x, res_y)
    transform_affine =  translate_affine*scale_affine
    

    print(transform_affine)

    
    print("File to resample:",file_raster)
    #### Se le el raster original
    rast_pblh_r=  rasterio.open(file_raster , 'r', driver='Gtiff')
    res_arr = rast_pblh_r.read(
        out_shape=(
            1,
            int(n_pixel_x),
            int(n_pixel_y)
        ),
        resampling=Resampling.bilinear
    )

    
    

    #### Se copian los metadatos igual que el raster original     

    kwargs = rast_pblh_r.meta.copy()
    kwargs.update({
        'transform': transform_affine,
        'width': int(n_pixel_x),
        'height':int(n_pixel_y)
    })
    

    #### Se abre el archivo donde se guarda el raster resampleado
    print("Saving file at:",file_save_resample)
    print(kwargs)
    dst_resample = rasterio.open(file_save_resample,
        'w', 
        **kwargs
    )
    dst_resample.write(res_arr)
    dst_resample.set_band_description(1, "PBLH")
    dst_resample.description= ("PBLH")
    if set_date_file:
        file_raster_s = file_raster[file_raster.rfind("/")+1:]
        num_pos = re.search(r"\d",file_raster_s)
        str_date = file_raster_s[num_pos.start():file_raster_s.rfind('.')]
        #ls_date=str_date.split("_")
        print(str_date)
        date_str  = datetime.strptime(str_date,"%Y_%m_%d").date().strftime("%Y-%m-%d")

        dst_resample.update_tags(1, DATETIME=date_str)

    dst_resample.close()
    rast_pblh_r.close()
    return 

# %% ../get_PBLH_program.ipynb 13
def getFeatures(gdf):
    """Function to parse features from GeoDataFrame in such a manner that rasterio wants them"""
    import json
    return [json.loads(gdf.to_json())['features'][0]['geometry']]

# %% ../get_PBLH_program.ipynb 14
def cut_bbox_zona_met (
        path_raster,
        path_poly_zm,
        save_raster_cut,
        verbose = False 

        ):
    """Cut raster to the metropolitan area"""
    ZM_df= gpd.read_file (path_poly_zm)
    bbox_ZM = shapely.geometry.box(*ZM_df.total_bounds)
    gdf_bb= gpd.GeoDataFrame({'geometry': bbox_ZM}, index=[0], crs=ZM_df.crs)
    coords = getFeatures(gdf_bb)
    print(coords)
    raster_open= rasterio.open(
        path_raster,
        'r', 
         driver =  'GTiff'
    )
    gdf_bb = gdf_bb.to_crs(crs=raster_open.meta['crs'])
    coords = getFeatures(gdf_bb)
    print(coords)
    out_img, out_transform = mask( dataset=raster_open, 
                                  shapes=coords, 
                                  all_touched=True,
                                  crop=True,
                                  nodata = np.nan
                                  )
    if verbose:
        print("shape image: ",out_img.shape )
    out_meta = raster_open.meta.copy()
    out_meta.update({"driver": "GTiff",
            "height": out_img.shape[1]-2,
            "width": out_img.shape[2]-1,
            "transform": out_transform,
            "crs":raster_open.meta['crs']}
    )
    with rasterio.open(
        save_raster_cut,
        "w", 
        **out_meta) as raster_cut:
        raster_cut.write(out_img)
        raster_cut.set_band_description(1,raster_open.descriptions[0])
        raster_cut.update_tags(1, DATETIME=raster_open.tags(1)["DATETIME"])
        raster_cut.close()
    return


# %% ../get_PBLH_program.ipynb 31
def add_band(raster_single, 
            raster_multiple, 
            raster_save
            ):
    """
    Add a band in the raster_single file to the raster in the 
    raster_multiple
    """
    print('read file single band: ' ,raster_single )
    raster_single_ras= rasterio.open(
        raster_single,
        "r"
    )
    print('read file multiple bands: ' ,raster_multiple )
    raster_multiple_ras = rasterio.open(
        raster_multiple,
        "r"
    )
    kwargs_save = raster_multiple_ras.meta.copy()
    des_mul = list(raster_multiple_ras.descriptions)
    des_mul.append("PBLH")
    des_mul = tuple(des_mul)
    kwargs_save.update({
        "count":raster_multiple_ras.count +1,
        "descriptions":des_mul,
    })
    print('saving file with all bands: ' ,raster_save)
    save_raster =  rasterio.open(
        raster_save, 
        "w",
        **kwargs_save
    )
    for i in range(1, save_raster.count+1):
        if i < save_raster.count:
            save_raster.write(raster_multiple_ras.read(i), i)
            save_raster.set_band_description(i, des_mul[i-1])


        else:
            save_raster.write(raster_single_ras.read(1), i)
            save_raster.set_band_description(i, des_mul[i-1])
            save_raster.update_tags(i, DATETIME=raster_single_ras.tags(1)["DATETIME"])
    
    

    save_raster.descriptions = kwargs_save["descriptions"]
    save_raster.close()

    return


# %% ../get_PBLH_program.ipynb 34
def res_bound_merge(
        day_mean_raster, # day mean raster 
        multilayer_raster, # multiple band raster to merge 
        save_final_raster, # path to save raster
        path_dir_resamp, #path to dir to save the resample 
        path_metropolitan_polygon, #Path to the metropolityan polygon
        path_dir_resa_cut, # path to saving the cut 
        
        dic_grib_info, # dictionary with the propertiies obtain from the grib file

    ):
    """
    Obtiene el rasampling, el bounding box de la zona metropolitana 
    y pega los rasters en un solo archivo como bandas.

    """
    
    
    
    start_pos= day_mean_raster.rfind("/")
    pos_re = day_mean_raster[start_pos:].find('_')
    path_resam_save = path_dir_resamp + day_mean_raster[start_pos+1:start_pos+pos_re]+"_resample"+day_mean_raster[start_pos+pos_re:] 
    print("Generating resample: ", path_resam_save)
    resample_raster(
        day_mean_raster, 
        multilayer_raster,
        path_resam_save,
        dic_grib_info,
        set_date_file = True 
    )
    ### get cut
    start_pos= path_resam_save.rfind("/")
    end_pos= path_resam_save.rfind(".tif")
    all_space  = path_resam_save[start_pos+1:end_pos].split("_")
    all_space.insert(2, 'cut') 
    all_space = '_'.join(all_space) + ".tif"
    file_cut = path_dir_resa_cut + all_space
    
    print("Generating cut: ", file_cut)
    print( path_metropolitan_polygon)
    cut_bbox_zona_met (
         path_resam_save,
         path_metropolitan_polygon,
         file_cut,
         verbose = True
    )

    #### Add bands 
    start_pos= multilayer_raster.rfind("/")
    end_pos= multilayer_raster.rfind(".tif")
    all_space  = multilayer_raster[start_pos+1:end_pos].split("_")
    all_space[2]="PBLH"
    
    
    all_space = '_'.join(all_space) + ".tif"
    file_final = save_final_raster + all_space
    print("Generating all bands: ", file_final)
    add_band(
        file_cut,
        multilayer_raster,
        file_final
        )
    return 
